#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    irleft,         sensorReflection)
#pragma config(Sensor, in2,    irright,        sensorReflection)
#pragma config(Sensor, dgtl1,  button1,        sensorTouch)
#pragma config(Sensor, dgtl2,  button2,        sensorTouch)
#pragma config(Sensor, dgtl3,  leftlimit,      sensorTouch)
#pragma config(Sensor, dgtl5,  rangesensor,    sensorSONAR_mm)
#pragma config(Sensor, dgtl7,  rightlimit,     sensorTouch)
#pragma config(Sensor, dgtl11, redLEDleft,     sensorDigitalOut)
#pragma config(Sensor, dgtl12, redLEDright,    sensorDigitalOut)
#pragma config(Sensor, I2C_1,  RightMotor,     sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  LeftMotor,      sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           RightMotor,    tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port2,           LeftMotor,     tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port3,           placer,        tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
Emily Murray 
Josie Peou
Tatum Maclean
*/


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///VARIABLES///CHANGE VALUES HERE///NOT IN FUNCTIONS PLEASE//////VARIABLES///CHANGE VALUES HERE///NOT IN FUNCTIONS PLEASE///
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


///SPEED VARIABLES///
int right_motor_diff = 1.87;
int fast_speed = 50;
int slow_speed = 30;
int fast_turn_speed = 40;
int slow_turn_speed = 30;
int placer_speed = 45;


///TIME VARIABLES///
int placement_time = 200; //in milliseconds
int reset_time = 500; //needed to ensure rocking doesn't occur
int celebrate_time = 150;


///ENCODER VARIABLES///
int turn360 = 2500;
int turn180 = 1900;
int turn90 = 1050;

///RANGEFINDER VARIABLES///
///Sensor only usable to 30mm per website///
int close_to_target = 800; //in millimeters
int close = 120; //in millimeters
int too_close = 50; //in millimeters
int second_scan_close= 250;
int min_distance_max_diff=50;

///IR VARAIBLES///
int max_ir_diff=50;
int ambient_ir=30;


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////HELPER FUNCTIONS//////////////////////////////////////////////HELPER FUNCTIONS///////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///RIGHT LIGHT ON///////////////////////////////////////////////////////////////////////////////////////////////////////////
void rightlightson()//used to signal robot is at correct distance (from wall or target)
{
		SensorValue(redLEDright)= 1;
		SensorValue(redLEDleft)= 0;
}
///LEFT LIGHT ON/////////////////////////////////////////////////////////////////////////////////////////////////////////////
void leftlightson()//used to signal robot is too close to wall or target
{
		SensorValue(redLEDright)= 0;
		SensorValue(redLEDleft)= 1;
}
///BOTH LIGHTS ON/////////////////////////////////////////////////////////////////////////////////////////////////////////////
void bothlightson()//used to signal robot is too far from wall or target
{
		SensorValue(redLEDright)= SensorValue(redLEDleft)= 1;
}
///STOP RESET WAIT///////////////////////////////////////////////////////////////////////////////////////////////////////////
void stopresetwait()//used to reset motor encoders, turn all motors and wait before moving on
{
		motor[RightMotor] = motor[LeftMotor]= motor[placer]= 0;
		resetMotorEncoder(RightMotor);
		resetMotorEncoder(LeftMotor);
		wait1Msec(reset_time);
}

///TURN (ROTATIONS, direction)//////////////////////////////////////////////////////////////////////////////////////////////////
void turn(int rotation, int speed)//helper function to turn robot a specified distance
{
		stopresetwait(); //reset encoders to get correct measurements
		while(abs(getMotorEncoder(LeftMotor))<rotation){ //while encoder is less than rotation value turn
				motor[LeftMotor]= speed;
		}
	 	stopresetwait();
}


///GO STRAIGHT//////////////////////////////////////////////////////////////////////////////////////////////////////////
void gostraight(int speed)//keep robot  moving in a straight line
{
		if(abs(getMotorEncoder(RightMotor))<abs((getMotorEncoder(LeftMotor)))){//if left wheels have moved more than right, make right go faster and left go slower
			//writeDebugStream("\n\n inside go straight left is faster go make right go faster\n ");
			motor[RightMotor]= (speed)*5/3;
			motor[LeftMotor]= -(speed)*2/3;
		}
		if(abs((getMotorEncoder(LeftMotor)))<abs(getMotorEncoder(RightMotor))){//if left wheels have moved less than right, make right go slower and left go faster
			//writeDebugStream("inside go straight right is faster go make left go faster\n ");
			motor[LeftMotor]= -(speed)*5/3;
			motor[RightMotor]= (speed)*2/3;
		}
		if(abs((getMotorEncoder(LeftMotor)))==abs(getMotorEncoder(RightMotor))){//if both wheels have moved same distance, both wheels go same speed
			//writeDebugStream("inside go straight both are same speed\n ");
			motor[LeftMotor]= -(speed);
			motor[RightMotor]= (speed);
		}
}

///READ LEFT IR////////////////////////////////////////////////////////////////////////////////////////////////////
int readleftir()//used to find the larget difference in ir reading in 0.1s. This will result in the beacon having the largest value return and all ambient ir with values between 0-30.
{
	int maxIR=0;
	int minIR=500;
	int diffIR=0;
	clearTimer(T1);
	while(time1[T1]<=100){
		int curIR= SensorValue[irleft];
		if(time1[T1]<100){//while timer is under 0.1 second (which is 10Hz)
			if(curIR<minIR){//find lowest ir reading
				minIR=curIR;
			}
			if(curIR>maxIR){//find highest ir reading
				maxIR=curIR;
			}
		}else {//when timer is exactly 0.1 seconds
			diffIR=maxIR-minIR;//compute the difference between the largest and small ir readings
			//writeDebugStream("inside readleftir(): diffIR: %d \n ", diffIR);
			maxIR=0;//reset values for next reading
			minIR=500;
			clearTimer(T1);//clear timer for next reading
			return abs(diffIR);//return the absolute value of the difference calculated
		}
	}
	return -1;
}

///READ RIGHT IR////////////////////////////////////////////////////////////////////////////////////////////////////
int readrightir()//same system as above but for the right ir
{
	int maxIR=0;
	int minIR=500;
	int diffIR=0;
	clearTimer(T1);
	while(time1[T1]<=100){
		int curIR= SensorValue[irright];
		if(time1[T1]<100){
			if(curIR<minIR){
				minIR=curIR;
			}
			if(curIR>maxIR){
				maxIR=curIR;
			}
		}else {
			diffIR=maxIR-minIR;
			writeDebugStream("inside readrightir(): diffIR: %d \n ", diffIR);
			maxIR=0;
			minIR=500;
			clearTimer(T1);
			return abs(diffIR);
		}
	}
	return -1;
}

///TARGET ACQUIRED//////////////////////////////////////////////////////////////////////
bool targetaquired()//used to ensure robot is aligned with target as it moves towards is
{
	//writeDebugStream("\n ");
	//writeDebugStream("inside targetacquired()\n ");
	int right=readrightir();
	int left= readleftir();
	if(right>ambient_ir && left>ambient_ir){//if both left ir and right ir are reading above the ambient ir levels move
		if(right<=(left+20) && right>=(left-20)){//and if left and right ir between 20 of each other(which means they are centered to the beacon), return true
			//writeDebugStream("targetacquired()==true\n ");
			return true;
		}
	}
	//writeDebugStream("targetacquired==false\n ");
	return false;
}

///READ RANGE FINDER///////////////////////////////////////////////////////////////////////////////////////////////////////////////
int readrange()//used to weed out outlier readings
{
	int one= SensorValue(rangesensor);
	wait1Msec(70);
	int two= SensorValue(rangesensor);
	wait1Msec(70);
	int three= SensorValue(rangesensor);//read 3 values from rangesensor
	wait1Msec(70);//0.7s is the reading time of the rangesensor per web research
	if(one<two && one>three || one>two && one<three){
		return one;
	}
	else if(two<one && two>three || two>one && two<three){
		return two;
	}
	else{
		return three;//return the median value of the 3 read
	}
}
///FIND MIN DISTANCE/////////////////////////////////////////////////////////////////////
int findmindistance()//used to find the minimum distance form the wall by rotating 180 degrees and returning the smallest rangesensor value
{
	stopresetwait();
	int mindistance=10000;
	while(abs(getMotorEncoder(LeftMotor))<turn180){//turn180 used because if it was larger wew would risk reading the beacon distance and not wall
			motor[LeftMotor]= slow_turn_speed;
			if(readrange()<mindistance){
				mindistance=SensorValue(rangesensor);
			}
	}
	stopresetwait();
	return mindistance;
}

///PLACER MOTOR////////////////////////////////////////////////////////////////////
void placermotor(int time)//used reduce redundancy in code when running motor as we always have it running the same way
{
		motor[placer]= placer_speed; //speed of placement motor is always the same
	 	wait1Msec(time); //run motor for a specified time period
	 	motor[placer]=0;
	 	wait1Msec(reset_time);
		motor[placer]= -(placer_speed); //run motor backwards back to initial setup
	 	wait1Msec(time);
	 	motor[placer]=0;
	}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////TASK FUNCTIONS////////////////////////////////////////////////TASK FUNCTIONS////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
typedef enum STATE{
    STAND_BY,
    FIND_TARGET,
    FORWARD_UNTIL_CLOSE,
    PLACE_BALL,
    FIND_WALL,
    CELEBRATE_COMPLETION,
};

///STANDBY/////////////////////////////////////////////////////////////////////////////////////////////////////////////
STATE standby()//wait until button 1 is pushed to begin
{
	stopresetwait();
	SensorValue(redLEDright)= 0;
	SensorValue(redLEDleft)= 0;
	if(SensorValue(button1)==1){
		//writeDebugStream("\n\n\nNEW RUN \n ");
		stopresetwait();
		return FIND_TARGET;
	}else{
		return STAND_BY;
	}
}


///FIND TARGET/////////////////////////////////////////////////////////////////////////////////////////////////////
STATE findtarget()//find the target using 2 ir phototransitors
{
	//writeDebugStream("\n\n ");
	//writeDebugStream("inside findtarget()\n ");
	stopresetwait();
	int rightir=0;//set ir reading as 0
	int leftir=0;
	while(abs(getMotorEncoder(LeftMotor))<turn360){//while turning 360 degrees reaad both phototransitors
		motor[RightMotor]= slow_turn_speed*right_motor_diff;
		motor[LeftMotor]= slow_turn_speed;
		int newrightir=readrightir();//call readir functions to return the largest difference found in the leat 0.1s
		//writeDebugStream("value returned from readrightir() (should be same as above): %d \n ", newrightir);
		int newleftir=readleftir();
		//writeDebugStream("value returned from readlefttir() (should be same as above): %d \n ", newleftir);
		if(newrightir>rightir){//if the ir difference read is larger than the largest previous reading replace the previous reading with the new one
			rightir=newrightir;
		}
		if(newleftir>leftir){
			leftir=newleftir;
		}
	}

	//writeDebugStream("largest rightir diff: %d \n ", rightir);
	//writeDebugStream("largest leftir diff: %d \n ", leftir);

	stopresetwait();
	while(abs(getMotorEncoder(LeftMotor))<turn360){//turn until both ir phototransitors are reading roughly the same value (means robot is centred to target)
		motor[RightMotor]= -slow_turn_speed*right_motor_diff;
		motor[LeftMotor]= -slow_turn_speed;

		if(readrightir()>rightir-max_ir_diff && readleftir()>leftir-max_ir_diff){
			stopresetwait();
			bothlightson();
			wait1Msec(1000);
			return FORWARD_UNTIL_CLOSE;
		}

		//writeDebugStream("Target not detected, continuing to look\n ");

	}
	return FIND_TARGET;
}

///FORWARD UNITL CLOSE/////////////////////////////////////////////////////////////////
STATE forwarduntilclose()//robot moves towards robot uses rangesenor for distance and ir phototransitors for alignment
{
		//writeDebugStream("\n\n inside forwarduntilclose\n ");
			stopresetwait();
			while(readrange()>close_to_target){//while target is far away to go fast to get to target
					//writeDebugStream("\n\n inside forwarduntilclose very far away\n ");
					bothlightson();
					gostraight(fast_speed);
					if(SensorValue(rightlimit)==1){//if a wall is hit, back up and return FIND_TARGET to enter back into findtarget function
						gostraight((-slow_speed));
						wait1Msec(1500);
						return FIND_TARGET;
					}
					if(SensorValue(leftlimit)==1){//if a wall is hit, back up and return FIND_TARGET to enter back into findtarget function
						gostraight((-slow_speed));
						wait1Msec(1500);
						return FIND_TARGET;
					}
				}

				if(targetaquired()==false){//if robot is no longer centered to beacon enter back into find target function
					//writeDebugStream("inside forwarduntilclose, target is between close to traget and find wall target is not acquired");
					findtarget();
				}
				while(readrange()>second_scan_close){//while target is close go slow to get to target
					//writeDebugStream("\n\n inside forwarduntilclose far away\n ");
					bothlightson();
					gostraight(slow_speed);
					if(SensorValue(rightlimit)==1){//if a wall is hit, back up and return FIND_TARGET to enter back into findtarget function
						gostraight((-slow_speed));
						wait1Msec(1500);
						return FIND_TARGET;
					}
					if(SensorValue(leftlimit)==1){//if a wall is hit, back up and return FIND_TARGET to enter back into findtarget function
						gostraight((-slow_speed));
						wait1Msec(1500);
						return FIND_TARGET;
					}
				}
				if(targetaquired()==false){//if robot is no longer centered to beacon enter back into find target function
					//writeDebugStream("inside forwarduntilclose, target is between close to traget and find wall target is not acquired");
					findtarget();
					wait1Msec(1000);
				}
				while(readrange()>close){//while target is far away to go fast to get to target
					//writeDebugStream("\n\n inside forwarduntilclose far away\n ");
					bothlightson();
					gostraight(slow_speed);
					if(SensorValue(rightlimit)==1){//if a wall is hit, back up and return FIND_TARGET to enter back into findtarget function
						gostraight((-slow_speed));
						wait1Msec(1500);
						return FIND_TARGET;
					}
					if(SensorValue(leftlimit)==1){//if a wall is hit, back up and return FIND_TARGET to enter back into findtarget function
						gostraight((-slow_speed));
						wait1Msec(1500);
						return FIND_TARGET;
					}

				}
				stopresetwait();
				if(readrange()<=too_close){//if robot is too close to target back up
					//writeDebugStream("\n\n inside forwarduntilclose too close\n ");
					leftlightson();
					gostraight((-slow_speed));
					wait1Msec(200);
					if(SensorValue(rightlimit)==1){//if a wall is hit, back up and return FIND_TARGET to enter back into findtarget function
						gostraight((-slow_speed));
						wait1Msec(1500);
						return FIND_TARGET;
					}
					if(SensorValue(leftlimit)==1){//if a wall is hit, back up and return FIND_TARGET to enter back into findtarget function
						gostraight((-slow_speed));
						wait1Msec(1500);
						return FIND_TARGET;
					}
				}
			stopresetwait();
			rightlightson();
			//writeDebugStream("\n inside forwarduntilclose finished and going to place ball\n ");
			return PLACE_BALL;


}

///PLACEMENT///////////////////////////////////////////////////////////////////////////////////
STATE placement()//place ball on beacon using placer motor
{
		//writeDebugStream("\n\n inside placement\n ");
		rightlightson();
		placermotor(placement_time);
	 	//writeDebugStream("inside placement, going to find wall\n ");
	 	return FIND_WALL;//once placement is complete bobot moves to FIND_WALL state
}

///FIND WALL////////////////////////////////////////////////////////////////////////////////////
STATE findwall()//find the closest wall to stop in front of
{
	//writeDebugStream("\n\n inside findwall\n ");
	stopresetwait();
	gostraight((-fast_speed));//backwup to get away from beacon
	wait1Msec(800);
	turn(turn90, fast_turn_speed);//turn90 that way we do not scan from min distance infront of beacon (this would cuase robot to go back to target)
	int mindistance = findmindistance();//call mindistance function to find the min distance to a wall
	//writeDebugStream("inside findwall min distance is %d\n ", mindistance);
	stopresetwait();
	while(readrange()>mindistance+min_distance_max_diff){//stop turning when rangesensor reads the mindistance less a tolerance
			motor[LeftMotor]= -slow_turn_speed;//turn in opposite direction as findmindistance fundtion that way we are scanning the same area as before
	}

	stopresetwait();
	while(readrange()>close_to_target || readrange()<0){//go straight towards wall
			bothlightson();
			gostraight(fast_speed);
			if(SensorValue(rightlimit)==1){//if hit wall start findwall over again
				gostraight((-slow_speed));
				wait1Msec(1500);
				findwall();
			}
			if(SensorValue(leftlimit)==1){//if hit wall start findwall over again
				gostraight((-slow_speed));
				wait1Msec(1500);
				findwall();
			}
	}
		while(readrange()<=close_to_target && readrange()>close){
			bothlightson();
			gostraight(slow_speed);
			if(SensorValue(rightlimit)==1){//if hit wall start findwall over again
				gostraight((-slow_speed));
				wait1Msec(1500);
				findwall();
			}
			if(SensorValue(leftlimit)==1){//if hit wall start findwall over again
				gostraight((-slow_speed));
				wait1Msec(1500);
				findwall();
			}
		}
		stopresetwait();
		while(readrange()<=too_close){
			leftlightson();
			gostraight((-slow_speed));
			if(SensorValue(rightlimit)==1){//if hit wall start findwall over again
				gostraight((-slow_speed));
				wait1Msec(1500);
				findwall();
			}
			if(SensorValue(leftlimit)==1){//if hit wall start findwall over again
				gostraight((-slow_speed));
				wait1Msec(1500);
				findwall();
			}
		}
		stopresetwait();
		SensorValue(redLEDright)= 0;
		SensorValue(redLEDleft)= 0;
	return CELEBRATE_COMPLETION;
}

///CELEBRATE_COMPLETION//////////////////////////////////////////////////////////////////////
STATE celebrate()//run the placer motor times as a celebration
{
		writeDebugStream("\n\n inside celebrate\n ");
		SensorValue(redLEDright)= 0;//both lights off to signal robot is close enough to wall
		SensorValue(redLEDleft)= 0;
		rightlightson();
		placermotor(celebrate_time);
	 	placermotor(celebrate_time);
		placermotor(celebrate_time);
		return STAND_BY;//return to standby state so that bobot is ready for another test
}


task main()
{
	STATE bobot_state = standby();

		while(true)
		{
			///*
			switch(bobot_state)
			{
				case(STAND_BY):
					bobot_state = standby();
					break;
				case(FIND_TARGET):
					bobot_state = findtarget();
					//wait1Msec(1000);
					break;
				case(FORWARD_UNTIL_CLOSE):
					bobot_state = forwarduntilclose();
					//wait1Msec(1000);
					break;
				case(PLACE_BALL):
					bobot_state = placement();
					//wait1Msec(1000);
					break;
				case(FIND_WALL):
					bobot_state = findwall();
					//wait1Msec(1000);
					break;
				case(CELEBRATE_COMPLETION):
					bobot_state = celebrate();
					//wait1Msec(1000);
					break;
			}//switch closed


		}//while closed

}//main closed
